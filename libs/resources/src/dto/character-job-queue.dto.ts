import { toGuid } from '../transformers';
import { OSINT_SOURCE } from '../constants';
import { Logger } from '@nestjs/common';

/**
 * Character Job Queue DTO
 *
 * Comprehensive data transfer object for character jobs added to the characterQueue.
 * Includes static factory methods for each source with automatic guid generation,
 * validation, and transformation logic.
 *
 * SOURCES:
 * @see LadderService - M+ and PvP ladders (priority: 2-3)
 * @see WarcraftLogsService - Raid report characters (priority: 2)
 * @see WowProgressLfgService - LFG listings (priority: 2)
 * @see GuildRosterService - Guild masters (priority: high)
 * @see CharactersService - Character index (priority: 5)
 *
 * GUID FORMAT:
 * - Generated by toGuid(name, realm)
 * - Kebab-case, lowercased, trimmed, no spaces
 * - Format: "character-name@realm-slug"
 * - Example: toGuid('Thrall', 'Area 52') => 'thrall@area-52'
 */

/**
 * Base interface for creating character job queue entries
 * Only requires essential fields; guid is auto-generated from name + realm
 */
export interface ICharacterJobQueueBase {
  /** Character name (will be converted to kebab-case for guid) */
  name: string;
  /** Realm slug (will be converted to kebab-case for guid) */
  realm: string;
  /** API key credentials */
  clientId: string;
  clientSecret: string;
  accessToken: string;
  /** Force update threshold in milliseconds */
  forceUpdate: number;
  /** Only create if character doesn't exist */
  createOnlyUnique: boolean;
  /** Source that last updated this job */
  updatedBy: OSINT_SOURCE;
  /** Source that created this job (optional, defaults to updatedBy) */
  createdBy?: OSINT_SOURCE;
}

export class CharacterJobQueueDto {
  private static readonly logger = new Logger(CharacterJobQueueDto.name);

  readonly guid: string;
  readonly name: string;
  readonly realm: string;
  readonly realmId?: number;
  readonly realmName?: string;
  readonly guild?: string;
  readonly guildGuid?: string;
  readonly guildId?: number;
  readonly guildRank?: number;
  readonly class?: string;
  readonly race?: string;
  readonly faction?: string;
  readonly level?: number;
  readonly specialization?: string;
  readonly gender?: string;
  readonly lookingForGuild?: string;
  readonly updateRIO?: boolean;
  readonly updateWCL?: boolean;
  readonly updateWP?: boolean;
  readonly forceUpdate: number;
  readonly createOnlyUnique: boolean;
  readonly iteration?: number;
  readonly createdBy?: OSINT_SOURCE;
  readonly updatedBy: OSINT_SOURCE;
  readonly clientId?: string;
  readonly clientSecret?: string;
  readonly accessToken?: string;
  readonly region: 'eu';
  readonly createdAt?: Date;
  readonly updatedAt?: Date;
  readonly lastModified?: Date;
  readonly id?: number;
  readonly achievementPoints?: number;
  readonly averageItemLevel?: number;
  readonly equippedItemLevel?: number;
  readonly covenantId?: number;
  readonly mountsNumber?: number;
  readonly petsNumber?: number;
  readonly avatarImage?: string;
  readonly insetImage?: string;
  readonly mainImage?: string;
  readonly statusCode?: number;
  readonly hashA?: string;
  readonly hashB?: string;
  readonly hashF?: string;

  /**
   * Direct constructor - use when you already have a guid or need full control
   * @param data - Complete or partial character job queue data
   */
  constructor(data: Partial<CharacterJobQueueDto>) {
    Object.assign(this, data);
    // Set default region if not provided
    if (!this.region) {
      (this as any).region = 'eu';
    }
  }

  /**
   * Create with auto-generated guid from name and realm
   * @param data - Character job data without guid
   * @returns New CharacterJobQueueDto instance with generated guid
   */
  static create(
    data: Omit<Partial<CharacterJobQueueDto>, 'guid'> &
      Pick<ICharacterJobQueueBase, 'name' | 'realm'>,
  ): CharacterJobQueueDto {
    const guid = toGuid(data.name, data.realm);
    const dto = new CharacterJobQueueDto({
      ...data,
      guid,
      createdBy: data.createdBy || data.updatedBy,
    });
    dto.validate(false, 'CharacterJobQueueDto.create');
    return dto;
  }

  /**
   * Create from Mythic+ Ladder data
   * Pattern: LadderService.indexMythicPlusLadder
   */
  static fromMythicPlusLadder(params: {
    name: string;
    realm: string;
    faction: string;
    clientId: string;
    clientSecret: string;
    accessToken: string;
  }): CharacterJobQueueDto {
    const guid = toGuid(params.name, params.realm);
    const dto = new CharacterJobQueueDto({
      guid,
      name: params.name,
      realm: params.realm,
      faction: params.faction,
      forceUpdate: 14400000, // 4 hours
      region: 'eu',
      createdBy: OSINT_SOURCE.MYTHIC_PLUS,
      updatedBy: OSINT_SOURCE.MYTHIC_PLUS,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
    });
    dto.validate(false, 'CharacterJobQueueDto.fromMythicPlusLadder');
    return dto;
  }

  /**
   * Create from PvP Ladder data
   * Pattern: LadderService.indexPvPLadder
   */
  static fromPvPLadder(params: {
    name: string;
    realm: string;
    faction: string;
    rank: number;
    clientId: string;
    clientSecret: string;
    accessToken: string;
  }): CharacterJobQueueDto {
    const guid = toGuid(params.name, params.realm);
    const dto = new CharacterJobQueueDto({
      guid,
      name: params.name,
      realm: params.realm,
      faction: params.faction,
      iteration: params.rank,
      forceUpdate: 14400000, // 4 hours
      region: 'eu',
      createdBy: OSINT_SOURCE.PVP_LADDER,
      updatedBy: OSINT_SOURCE.PVP_LADDER,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
    });
    dto.validate(false, 'CharacterJobQueueDto.fromPvPLadder');
    return dto;
  }

  /**
   * Create from Warcraft Logs raid data
   * Pattern: WarcraftLogsService.charactersToQueue
   */
  static fromWarcraftLogs(params: {
    name: string;
    realm: string;
    timestamp: number;
    clientId: string;
    clientSecret: string;
    accessToken: string;
  }): CharacterJobQueueDto {
    const guid = toGuid(params.name, params.realm);
    const dto = new CharacterJobQueueDto({
      guid,
      name: params.name,
      realm: params.realm,
      updatedAt: new Date(params.timestamp),
      forceUpdate: 60000, // 1 minute
      region: 'eu',
      createdBy: OSINT_SOURCE.WARCRAFT_LOGS,
      updatedBy: OSINT_SOURCE.WARCRAFT_LOGS,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
    });
    dto.validate(false, 'CharacterJobQueueDto.fromWarcraftLogs');
    return dto;
  }

  /**
   * Create from WoW Progress LFG data
   * Pattern: WowProgressLfgService.pushCharacterAndProfileToQueue
   */
  static fromWowProgressLfg(params: {
    name: string;
    realm: string;
    realmId: number;
    realmName: string;
    clientId: string;
    clientSecret: string;
    accessToken: string;
  }): CharacterJobQueueDto {
    const guid = toGuid(params.name, params.realm);
    const dto = new CharacterJobQueueDto({
      guid,
      name: params.name,
      realm: params.realm,
      realmId: params.realmId,
      realmName: params.realmName,
      forceUpdate: 1800000, // 30 minutes
      region: 'eu',
      createdBy: OSINT_SOURCE.WOW_PROGRESS_LFG,
      updatedBy: OSINT_SOURCE.WOW_PROGRESS_LFG,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
    });
    dto.validate(false, 'CharacterJobQueueDto.fromWowProgressLfg');
    return dto;
  }

  /**
   * Create from Guild Roster (Guild Master)
   * Pattern: GuildRosterService.queueGuildMasterUpdate
   */
  static fromGuildMaster(params: {
    name: string;
    realm: string;
    guild: string;
    guildNameSlug: string;
    guildId: number;
    class: string | null;
    faction: string;
    level: number | null;
    lastModified: Date;
    clientId: string;
    clientSecret: string;
    accessToken: string;
  }): CharacterJobQueueDto {
    const guid = toGuid(params.name, params.realm);
    const guildGuid = toGuid(params.guildNameSlug, params.realm);
    const dto = new CharacterJobQueueDto({
      guid,
      name: params.name,
      realm: params.realm,
      guild: params.guild,
      guildGuid,
      guildId: params.guildId,
      guildRank: 0, // Guild Master
      class: params.class || undefined,
      faction: params.faction,
      level: params.level || undefined,
      lastModified: params.lastModified,
      forceUpdate: 1, // Force immediate update
      region: 'eu',
      createdBy: OSINT_SOURCE.GUILD_ROSTER,
      updatedBy: OSINT_SOURCE.GUILD_ROSTER,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
    });
    dto.validate(false, 'CharacterJobQueueDto.fromGuildMaster');
    return dto;
  }

  /**
   * Create from Character Index (database)
   * Pattern: CharactersService.indexCharacters
   */
  static fromCharacterIndex(params: {
    guid: string;
    name: string;
    realm: string;
    iteration: number;
    clientId: string;
    clientSecret: string;
    accessToken: string;
    // All other CharactersEntity fields
    [key: string]: any;
  }): CharacterJobQueueDto {
    const dto = new CharacterJobQueueDto({
      ...params,
      region: 'eu',
      forceUpdate: 43200000, // 12 hours
      createdBy: OSINT_SOURCE.CHARACTER_INDEX,
      updatedBy: OSINT_SOURCE.CHARACTER_INDEX,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
      iteration: params.iteration,
    });
    dto.validate(false, 'CharacterJobQueueDto.fromCharacterIndex');
    return dto;
  }

  /**
   * Create from Guild Member (non-guild master)
   * Pattern: GuildRosterService.saveCharacterAsGuildMember
   */
  static fromGuildMember(params: {
    name: string;
    realm: string;
    realmId: number;
    realmName: string;
    guild: string;
    guildGuid: string;
    guildId: number;
    guildRank: number;
    class: string | null;
    faction: string;
    level: number | null;
    lastModified: Date;
    clientId: string;
    clientSecret: string;
    accessToken: string;
    id?: number;
  }): CharacterJobQueueDto {
    const guid = toGuid(params.name, params.realm);
    const dto = new CharacterJobQueueDto({
      guid,
      id: params.id,
      name: params.name,
      realm: params.realm,
      realmId: params.realmId,
      realmName: params.realmName,
      guild: params.guild,
      guildGuid: params.guildGuid,
      guildId: params.guildId,
      guildRank: params.guildRank,
      class: params.class || undefined,
      faction: params.faction,
      level: params.level || undefined,
      lastModified: params.lastModified,
      forceUpdate: 604800000, // 7 days - very conservative, guild members are low priority
      region: 'eu',
      createdBy: OSINT_SOURCE.GUILD_ROSTER,
      updatedBy: OSINT_SOURCE.GUILD_ROSTER,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
    });
    dto.validate(false, 'CharacterJobQueueDto.fromGuildMember');
    return dto;
  }

  /**
   * Create from S3 migration file
   * Pattern: CharactersService.indexFromFile
   */
  static fromMigrationFile(params: {
    guid: string;
    clientId: string;
    clientSecret: string;
    accessToken: string;
  }): CharacterJobQueueDto {
    const [nameSlug, realmSlug] = params.guid.split('@');
    const dto = new CharacterJobQueueDto({
      guid: params.guid,
      name: nameSlug,
      realm: realmSlug,
      region: 'eu',
      forceUpdate: 43200000, // 12 hours
      createdBy: OSINT_SOURCE.OSINT_MIGRATION,
      updatedBy: OSINT_SOURCE.OSINT_MIGRATION,
      createOnlyUnique: true, // Only create, don't update existing
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
    });
    dto.validate(false, 'CharacterJobQueueDto.fromMigrationFile');
    return dto;
  }

  /**
   * Validate that required fields are present
   * @param strict - If true, throws errors; if false, logs warnings
   * @param logTag - Optional log tag for warnings (defaults to 'CharacterJobQueueDto.validate')
   * @throws Error if validation fails and strict is true
   */
  validate(strict: boolean = true, logTag: string = 'CharacterJobQueueDto.validate'): void {
    const requiredFields = [
      'guid',
      'name',
      'realm',
      'forceUpdate',
      'createOnlyUnique',
      'updatedBy',
    ];

    // Check required fields
    for (const field of requiredFields) {
      if (this[field] === undefined || this[field] === null) {
        const message = `Validation failed: missing required field '${field}' for guid '${this.guid || 'unknown'}'`;
        if (strict) {
          throw new Error(message);
        } else {
          CharacterJobQueueDto.logger.warn({ logTag, message, guid: this.guid });
        }
      }
    }

    // Validate guid format
    if (this.guid && !this.guid.includes('@')) {
      const message = `Validation failed: guid '${this.guid}' must contain '@' separator`;
      if (strict) {
        throw new Error(message);
      } else {
        CharacterJobQueueDto.logger.warn({ logTag, message, guid: this.guid });
      }
    }

    // Validate forceUpdate is positive number
    if (
      this.forceUpdate !== undefined &&
      (typeof this.forceUpdate !== 'number' || this.forceUpdate < 0)
    ) {
      const message = `Validation failed: forceUpdate must be a positive number, got '${this.forceUpdate}' for guid '${this.guid || 'unknown'}'`;
      if (strict) {
        throw new Error(message);
      } else {
        CharacterJobQueueDto.logger.warn({
          logTag,
          message,
          guid: this.guid,
          forceUpdate: this.forceUpdate,
        });
      }
    }

    // Warn about missing optional credentials (non-blocking)
    if (!strict) {
      const credentials = ['clientId', 'clientSecret', 'accessToken'];
      const missingCredentials = credentials.filter(
        (field) => !this[field] || this[field] === undefined,
      );
      if (missingCredentials.length > 0) {
        CharacterJobQueueDto.logger.warn({
          logTag,
          message: `Missing optional credentials: ${missingCredentials.join(', ')}`,
          guid: this.guid,
          missingCredentials,
        });
      }
    }
  }

  /**
   * Create validated instance - throws if validation fails
   */
  static createValidated(
    data: Omit<Partial<CharacterJobQueueDto>, 'guid'> &
      Pick<ICharacterJobQueueBase, 'name' | 'realm'>,
  ): CharacterJobQueueDto {
    const dto = CharacterJobQueueDto.create(data);
    dto.validate();
    return dto;
  }
}
