import { toGuid } from '../transformers';
import { OSINT_SOURCE } from '../constants';
import { Logger } from '@nestjs/common';

/**
 * Guild Job Queue DTO
 *
 * Comprehensive data transfer object for guild jobs added to the guildsQueue.
 * Includes static factory methods for each source with automatic guid generation,
 * validation, and transformation logic.
 *
 * SOURCES:
 * @see GuildsService.indexGuildCharactersUnique() - Guilds from character rosters (priority: 1)
 * @see GuildsService.indexGuilds() - Guild database index (priority: 5)
 * @see GuildsService.indexHallOfFame() - Top guilds from Blizzard leaderboards (priority: 2)
 * @see WowProgressRanksService.transformWowProgressToGuildJobs() - WoW Progress rankings (priority: 3)
 * @see OsintService.getGuild() - Direct guild API request (priority: 1)
 *
 * GUID FORMAT:
 * - Generated by toGuid(name, realm)
 * - Kebab-case, lowercased, trimmed, no spaces
 * - Format: "guild-name@realm-slug"
 * - Example: toGuid('Thrall', 'Area 52') => 'thrall@area-52'
 */

/**
 * Base interface for creating guild job queue entries
 * Only requires essential fields; guid is auto-generated from name + realm
 */
export interface IGuildJobQueueBase {
  /** Guild name (will be converted to kebab-case for guid) */
  name: string;
  /** Realm slug (will be converted to kebab-case for guid) */
  realm: string;
  /** API key credentials */
  clientId?: string;
  clientSecret?: string;
  accessToken?: string;
  /** Force update threshold in milliseconds */
  forceUpdate: number;
  /** Only create if guild doesn't exist */
  createOnlyUnique: boolean;
  /** Source that last updated this job */
  updatedBy: OSINT_SOURCE;
  /** Source that created this job (optional, defaults to updatedBy) */
  createdBy?: OSINT_SOURCE;
}

export class GuildJobQueueDto {
  private static readonly logger = new Logger(GuildJobQueueDto.name);

  readonly guid: string;
  readonly name: string;
  readonly realm: string;
  readonly id?: number;
  readonly realmId?: number;
  readonly realmName?: string;
  readonly faction?: string;
  readonly statusCode?: number;
  readonly achievementPoints?: number;
  readonly emblemId?: number;
  readonly emblemColor?: string;
  readonly borderColor?: string;
  readonly backGroundColor?: string;
  readonly leaderboard?: string;
  readonly forceUpdate: number;
  readonly createOnlyUnique: boolean;
  readonly iteration?: number;
  readonly createdBy?: OSINT_SOURCE;
  readonly updatedBy: OSINT_SOURCE;
  readonly clientId?: string;
  readonly clientSecret?: string;
  readonly accessToken?: string;
  readonly region: 'eu';
  readonly createdAt?: Date;
  readonly updatedAt?: Date;

  /**
   * Direct constructor - use when you already have a guid or need full control
   * @param data - Complete or partial guild job queue data
   */
  constructor(data: Partial<GuildJobQueueDto>) {
    Object.assign(this, data);
    // Set default region if not provided
    if (!this.region) {
      (this as any).region = 'eu';
    }
  }

  /**
   * Create with auto-generated guid from name and realm
   * @param data - Guild job data without guid
   * @returns New GuildJobQueueDto instance with generated guid
   */
  static create(
    data: Omit<Partial<GuildJobQueueDto>, 'guid'> &
      Pick<IGuildJobQueueBase, 'name' | 'realm'>,
  ): GuildJobQueueDto {
    const guid = toGuid(data.name, data.realm);
    const dto = new GuildJobQueueDto({
      ...data,
      guid,
      createdBy: data.createdBy || data.updatedBy,
    });
    dto.validate(false, 'GuildJobQueueDto.create');
    return dto;
  }

  /**
   * Create from Guild Characters Unique (discovered from character rosters)
   * Pattern: GuildsService.indexGuildCharactersUnique
   */
  static fromGuildCharactersUnique(params: {
    name: string;
    realm: string;
    clientId: string;
    clientSecret: string;
    accessToken: string;
  }): GuildJobQueueDto {
    const guid = toGuid(params.name, params.realm);
    const dto = new GuildJobQueueDto({
      guid,
      name: params.name,
      realm: params.realm,
      forceUpdate: 14400000, // 4 hours
      region: 'eu',
      createdBy: OSINT_SOURCE.GUILD_CHARACTERS_UNIQUE,
      updatedBy: OSINT_SOURCE.GUILD_CHARACTERS_UNIQUE,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
    });
    dto.validate(false, 'GuildJobQueueDto.fromGuildCharactersUnique');
    return dto;
  }

  /**
   * Create from Guild Index (database guild roster)
   * Pattern: GuildsService.indexGuilds
   */
  static fromGuildIndex(params: {
    guid: string;
    name: string;
    realm: string;
    iteration: number;
    clientId: string;
    clientSecret: string;
    accessToken: string;
    // All other GuildsEntity fields
    [key: string]: any;
  }): GuildJobQueueDto {
    const dto = new GuildJobQueueDto({
      ...params,
      region: 'eu',
      forceUpdate: 14400000, // 4 hours
      createdBy: OSINT_SOURCE.GUILD_INDEX,
      updatedBy: OSINT_SOURCE.GUILD_INDEX,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
      iteration: params.iteration,
    });
    dto.validate(false, 'GuildJobQueueDto.fromGuildIndex');
    return dto;
  }

  /**
   * Create from Hall of Fame (Blizzard leaderboards)
   * Pattern: GuildsService.indexHallOfFame
   * Note: Only EU region is supported - any other region will be ignored and defaulted to EU
   */
  static fromHallOfFame(params: {
    name: string;
    realm: string;
    realmId: number;
    realmName: string;
    faction: string;
    rank: number;
    region?: 'eu' | 'us' | 'kr' | 'tw';
    clientId: string;
    clientSecret: string;
    accessToken: string;
  }): GuildJobQueueDto {
    const guid = toGuid(params.name, params.realm);
    // Log warning if non-EU region was provided
    if (params.region && params.region !== 'eu') {
      GuildJobQueueDto.logger.warn({
        logTag: 'GuildJobQueueDto.fromHallOfFame',
        message: `Non-EU region '${params.region}' provided but only EU is supported. Defaulting to 'eu'.`,
        guid,
        providedRegion: params.region,
      });
    }
    const dto = new GuildJobQueueDto({
      guid,
      name: params.name,
      realm: params.realm,
      realmId: params.realmId,
      realmName: params.realmName,
      faction: params.faction,
      iteration: params.rank,
      forceUpdate: 3600000, // 1 hour
      region: 'eu', // Always use EU
      createdBy: OSINT_SOURCE.TOP100,
      updatedBy: OSINT_SOURCE.TOP100,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
    });
    dto.validate(false, 'GuildJobQueueDto.fromHallOfFame');
    return dto;
  }

  /**
   * Create from WoW Progress rankings
   * Pattern: WowProgressRanksService.transformWowProgressToGuildJobs
   */
  static fromWowProgress(params: {
    name: string;
    realm: string;
    iteration: number;
    clientId: string;
    clientSecret: string;
    accessToken: string;
  }): GuildJobQueueDto {
    const guid = toGuid(params.name, params.realm);
    const dto = new GuildJobQueueDto({
      guid,
      name: params.name,
      realm: params.realm,
      iteration: params.iteration,
      forceUpdate: 43200000, // 12 hours
      region: 'eu',
      createdBy: OSINT_SOURCE.WOW_PROGRESS,
      updatedBy: OSINT_SOURCE.WOW_PROGRESS,
      createOnlyUnique: true, // Only create new, don't update existing
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
    });
    dto.validate(false, 'GuildJobQueueDto.fromWowProgress');
    return dto;
  }

  /**
   * Create from Guild Request (direct API request for specific guild)
   * Pattern: OsintService.getGuild
   */
  static fromGuildRequest(params: {
    name: string;
    realm: string;
    clientId?: string;
    clientSecret?: string;
    accessToken?: string;
  }): GuildJobQueueDto {
    const guid = toGuid(params.name, params.realm);
    const dto = new GuildJobQueueDto({
      guid,
      name: params.name,
      realm: params.realm,
      forceUpdate: 86400000, // 24 hours
      region: 'eu',
      createdBy: OSINT_SOURCE.GUILD_REQUEST,
      updatedBy: OSINT_SOURCE.GUILD_REQUEST,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
    });
    dto.validate(false, 'GuildJobQueueDto.fromGuildRequest');
    return dto;
  }

  /**
   * Validate that required fields are present
   * @param strict - If true, throws errors; if false, logs warnings
   * @param logTag - Optional log tag for warnings (defaults to 'GuildJobQueueDto.validate')
   * @throws Error if validation fails and strict is true
   */
  validate(strict: boolean = true, logTag: string = 'GuildJobQueueDto.validate'): void {
    const requiredFields = [
      'guid',
      'name',
      'realm',
      'forceUpdate',
      'createOnlyUnique',
      'updatedBy',
    ];

    // Check required fields
    for (const field of requiredFields) {
      if (this[field] === undefined || this[field] === null) {
        const message = `Validation failed: missing required field '${field}' for guid '${this.guid || 'unknown'}'`;
        if (strict) {
          throw new Error(message);
        } else {
          GuildJobQueueDto.logger.warn({ logTag, message, guid: this.guid });
        }
      }
    }

    // Validate guid format
    if (this.guid && !this.guid.includes('@')) {
      const message = `Validation failed: guid '${this.guid}' must contain '@' separator`;
      if (strict) {
        throw new Error(message);
      } else {
        GuildJobQueueDto.logger.warn({ logTag, message, guid: this.guid });
      }
    }

    // Validate forceUpdate is positive number
    if (
      this.forceUpdate !== undefined &&
      (typeof this.forceUpdate !== 'number' || this.forceUpdate < 0)
    ) {
      const message = `Validation failed: forceUpdate must be a positive number, got '${this.forceUpdate}' for guid '${this.guid || 'unknown'}'`;
      if (strict) {
        throw new Error(message);
      } else {
        GuildJobQueueDto.logger.warn({
          logTag,
          message,
          guid: this.guid,
          forceUpdate: this.forceUpdate,
        });
      }
    }

    // Warn about missing optional credentials (non-blocking)
    if (!strict) {
      const credentials = ['clientId', 'clientSecret', 'accessToken'];
      const missingCredentials = credentials.filter(
        (field) => !this[field] || this[field] === undefined,
      );
      if (missingCredentials.length > 0) {
        GuildJobQueueDto.logger.warn({
          logTag,
          message: `Missing optional credentials: ${missingCredentials.join(', ')}`,
          guid: this.guid,
          missingCredentials,
        });
      }
    }
  }

  /**
   * Create validated instance - throws if validation fails
   */
  static createValidated(
    data: Omit<Partial<GuildJobQueueDto>, 'guid'> &
      Pick<IGuildJobQueueBase, 'name' | 'realm'>,
  ): GuildJobQueueDto {
    const dto = GuildJobQueueDto.create(data);
    dto.validate();
    return dto;
  }
}
