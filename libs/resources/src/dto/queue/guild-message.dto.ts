import { toGuid } from '../../transformers';
import { OSINT_SOURCE, TIME_MS } from '../../constants';
import { Logger } from '@nestjs/common';
import { JobsOptions } from 'bullmq';
import { RegionIdOrName } from '@alexzedim/blizzapi';
import { guildsQueue } from '../../queues/guilds.queue';

/**
 * Guild Message DTO for BullMQ
 *
 * Comprehensive data transfer object for guild jobs with BullMQ.
 * Includes static factory methods for each source with automatic guid generation,
 * validation, and transformation logic.
 *
 * SOURCES:
 * @see GuildsService.indexGuildCharactersUnique() - Guilds from character rosters (priority: 7)
 * @see GuildsService.indexGuilds() - Guild database index (priority: 5)
 * @see GuildsService.indexHallOfFame() - Top guilds from Blizzard leaderboards (priority: 9)
 * @see WowProgressRanksService.transformWowProgressToGuildJobs() - WoW Progress rankings (priority: 6)
 * @see OsintService.getGuild() - Direct guild API request (priority: 8)
 *
 * GUID FORMAT:
 * - Generated by toGuid(name, realm)
 * - Kebab-case, lowercased, trimmed, no spaces
 * - Format: "guild-name@realm-slug"
 * - Example: toGuid('Thrall', 'Area 52') => 'thrall@area-52'
 */

/**
 * Base interface for creating guild job data
 * Only requires essential fields; guid is auto-generated from name + realm
 */
export interface IGuildMessageBase {
  id?: number;
  guid?: string;
  region: RegionIdOrName;
  /** Guild name (will be converted to kebab-case for guid) */
  name: string;
  /** Realm slug (will be converted to kebab-case for guid) */
  realm: string;
  /** Realm ID (for Hall of Fame) */
  realmId?: number;
  /** Realm name (for Hall of Fame) */
  realmName?: string;
  /** Faction (for Hall of Fame) */
  faction?: string;
  /** Iteration number (for guild index and WoW Progress) */
  iteration?: number;
  /** API key credentials */
  clientId?: string;
  clientSecret?: string;
  accessToken?: string;
  /** Force update threshold in milliseconds */
  forceUpdate: number;
  /** Only create if guild doesn't exist */
  createOnlyUnique: boolean;
  /** Source that last updated this job */
  updatedBy: OSINT_SOURCE;
  /** Source that created this job (optional, defaults to updatedBy) */
  createdBy?: OSINT_SOURCE;
}

export class GuildMessageDto {
  public readonly name: string;
  public readonly data: IGuildMessageBase;
  public readonly opts?: JobsOptions;

  private static readonly guildLogger = new Logger(GuildMessageDto.name);

  /**
   * Constructor - creates a validated Guild Message with BullMQ properties
   * @param name - Queue name (e.g., 'osint.guilds')
   * @param data - Guild message data
   * @param opts - BullMQ job options (optional)
   */
  constructor(name: string, data: IGuildMessageBase, opts?: JobsOptions) {
    this.name = name;
    this.data = data;
    this.opts = opts;
  }

  /**
   * Create with auto-generated guid from name and realm
   * @param data - Guild data with name and realm
   * @param opts - Optional job options
   * @returns New GuildMessageDto instance with generated guid
   */
  static create(
    data: Omit<Partial<IGuildMessageBase>, 'guid'> &
      Pick<IGuildMessageBase, 'name' | 'realm'>,
    opts?: JobsOptions,
  ): GuildMessageDto {
    const guid = toGuid(data.name, data.realm);
    const guildData: IGuildMessageBase = {
      ...data,
      guid,
      createdBy: data.createdBy || data.updatedBy,
    } as IGuildMessageBase;

    const mergedOpts = {
      ...guildsQueue.defaultJobOptions,
      ...opts,
    };

    const dto = new GuildMessageDto(guid, guildData, mergedOpts);
    dto.validate(false, 'GuildMessageDto.create');
    return dto;
  }

  /**
   * Create from Guild Characters Unique (discovered from character rosters)
   * Pattern: GuildsService.indexGuildCharactersUnique
   * Priority: 7
   */
  static fromGuildCharactersUnique(params: {
    name: string;
    realm: string;
    iteration?: number;
    clientId: string;
    clientSecret: string;
    accessToken: string;
  }): GuildMessageDto {
    const guid = toGuid(params.name, params.realm);
    const guildData: IGuildMessageBase = {
      guid,
      name: params.name,
      realm: params.realm,
      forceUpdate: TIME_MS.FOUR_HOURS,
      region: 'eu',
      createdBy: OSINT_SOURCE.GUILD_CHARACTERS_UNIQUE,
      updatedBy: OSINT_SOURCE.GUILD_CHARACTERS_UNIQUE,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
    };

    const opts: JobsOptions = {
      jobId: guid,
      ...guildsQueue.defaultJobOptions,
      priority: 7,
    };

    const dto = new GuildMessageDto(guid, guildData, opts);
    dto.validate(false, 'GuildMessageDto.fromGuildCharactersUnique');
    return dto;
  }

  /**
   * Create from Guild Index (database guild roster)
   * Pattern: GuildsService.indexGuilds
   * Priority: 5
   */
  static fromGuildIndex(params: {
    guid: string;
    name: string;
    realm: string;
    iteration?: number;
    clientId: string;
    clientSecret: string;
    accessToken: string;
    // All other GuildsEntity fields
    [key: string]: any;
  }): GuildMessageDto {
    const guildData: IGuildMessageBase = {
      ...params,
      region: 'eu',
      forceUpdate: TIME_MS.FOUR_HOURS,
      createdBy: OSINT_SOURCE.GUILD_INDEX,
      updatedBy: OSINT_SOURCE.GUILD_INDEX,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
      iteration: params.iteration,
    };

    const opts: JobsOptions = {
      jobId: guildData.guid,
      ...guildsQueue.defaultJobOptions,
      priority: 5,
    };

    const dto = new GuildMessageDto(guildData.guid, guildData, opts);
    dto.validate(false, 'GuildMessageDto.fromGuildIndex');
    return dto;
  }

  /**
   * Create from Hall of Fame (Blizzard leaderboards)
   * Pattern: GuildsService.indexHallOfFame
   * Note: Only EU region is supported - any other region will be ignored and defaulted to EU
   * Priority: 9
   */
  static fromHallOfFame(params: {
    id?: number;
    name: string;
    realm: string;
    realmId: number;
    realmName: string;
    faction: string;
    rank: number;
    region?: 'eu' | 'us' | 'kr' | 'tw';
    clientId: string;
    clientSecret: string;
    accessToken: string;
  }): GuildMessageDto {
    const guid = toGuid(params.name, params.realm);

    const guildData: IGuildMessageBase = {
      guid,
      id: params.id,
      name: params.name,
      realm: params.realm,
      realmId: params.realmId,
      realmName: params.realmName,
      faction: params.faction,
      iteration: params.rank,
      forceUpdate: TIME_MS.ONE_HOUR,
      region: 'eu',
      createdBy: OSINT_SOURCE.TOP100,
      updatedBy: OSINT_SOURCE.TOP100,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
    };

    const opts: JobsOptions = {
      jobId: guid,
      ...guildsQueue.defaultJobOptions,
      priority: 9,
    };

    const dto = new GuildMessageDto(guid, guildData, opts);
    dto.validate(false, 'GuildMessageDto.fromHallOfFame');
    return dto;
  }

  /**
   * Create from WoW Progress rankings
   * Pattern: WowProgressRanksService.transformWowProgressToGuildJobs
   * Priority: 6
   */
  static fromWowProgress(params: {
    name: string;
    realm: string;
    iteration: number;
    clientId: string;
    clientSecret: string;
    accessToken: string;
  }): GuildMessageDto {
    const guid = toGuid(params.name, params.realm);
    const guildData: IGuildMessageBase = {
      guid,
      name: params.name,
      realm: params.realm,
      iteration: params.iteration,
      forceUpdate: TIME_MS.TWELVE_HOURS,
      region: 'eu',
      createdBy: OSINT_SOURCE.WOW_PROGRESS,
      updatedBy: OSINT_SOURCE.WOW_PROGRESS,
      createOnlyUnique: true,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
    };

    const opts: JobsOptions = {
      jobId: guid,
      ...guildsQueue.defaultJobOptions,
      priority: 6,
    };

    const dto = new GuildMessageDto(guid, guildData, opts);
    dto.validate(false, 'GuildMessageDto.fromWowProgress');
    return dto;
  }

  /**
   * Create from Guild Request (direct API request for specific guild)
   * Pattern: OsintService.getGuild
   * Priority: 8
   */
  static fromGuildRequest(params: {
    name: string;
    realm: string;
    clientId?: string;
    clientSecret?: string;
    accessToken?: string;
  }): GuildMessageDto {
    const guid = toGuid(params.name, params.realm);
    const guildData: IGuildMessageBase = {
      guid,
      name: params.name,
      realm: params.realm,
      forceUpdate: TIME_MS.TWENTY_FOUR_HOURS,
      region: 'eu',
      createdBy: OSINT_SOURCE.GUILD_REQUEST,
      updatedBy: OSINT_SOURCE.GUILD_REQUEST,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
    };

    const opts: JobsOptions = {
      jobId: guid,
      ...guildsQueue.defaultJobOptions,
      priority: 8,
    };

    const dto = new GuildMessageDto(guildsQueue.name, guildData, opts);
    dto.validate(false, 'GuildMessageDto.fromGuildRequest');
    return dto;
  }

  /**
   * Validate that required fields are present
   * @param strict - If true, throws errors; if false, logs warnings
   * @param logTag - Optional log tag for warnings (defaults to 'GuildMessageDto.validate')
   * @throws Error if validation fails and strict is true
   */
  validate(
    strict: boolean = true,
    logTag: string = 'GuildMessageDto.validate',
  ): void {
    const guildData = this.data;

    if (guildData?.guid && !guildData.guid.includes('@')) {
      const message = `Validation failed: guid '${guildData.guid}' must contain '@' separator`;
      if (strict) {
        throw new Error(message);
      } else {
        GuildMessageDto.guildLogger.warn({
          logTag,
          message,
          guid: guildData.guid,
        });
      }
    }

    if (
      guildData?.forceUpdate !== undefined &&
      (typeof guildData.forceUpdate !== 'number' || guildData.forceUpdate < 0)
    ) {
      const message = `Validation failed: forceUpdate must be a positive number, got '${guildData.forceUpdate}' for guid '${guildData?.guid || 'unknown'}'`;
      if (strict) {
        throw new Error(message);
      } else {
        GuildMessageDto.guildLogger.warn({
          logTag,
          message,
          guid: guildData?.guid,
          forceUpdate: guildData?.forceUpdate,
        });
      }
    }

    // Log warning if non-EU region was provided
    if (guildData.region && guildData.region !== 'eu') {
      GuildMessageDto.guildLogger.warn({
        logTag: 'GuildMessageDto.fromHallOfFame',
        message: `Non-EU region '${guildData.region}' provided but only EU is supported. Defaulting to 'eu'.`,
        guid: guildData.guid,
        providedRegion: guildData.region,
      });
    }

    // Warn about missing optional credentials (non-blocking)
    if (!strict) {
      const credentials = ['clientId', 'clientSecret', 'accessToken'];
      const missingCredentials = credentials.filter(
        (field) => !guildData?.[field] || guildData?.[field] === undefined,
      );
      if (missingCredentials.length > 0) {
        GuildMessageDto.guildLogger.warn({
          logTag,
          message: `Missing optional credentials: ${missingCredentials.join(', ')}`,
          guid: guildData?.guid,
          missingCredentials,
        });
      }
    }
  }

  /**
   * Create validated instance - throws if validation fails
   */
  static createValidated(
    data: Omit<Partial<IGuildMessageBase>, 'guid'> &
      Pick<IGuildMessageBase, 'name' | 'realm'>,
    opts?: JobsOptions,
  ): GuildMessageDto {
    const dto = GuildMessageDto.create(data, opts);
    dto.validate();
    return dto;
  }
}
