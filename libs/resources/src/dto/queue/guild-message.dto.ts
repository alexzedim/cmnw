import { toGuid } from '../../transformers';
import { OSINT_SOURCE } from '../../constants';
import { Logger } from '@nestjs/common';
import { IRabbitMQMessageBase, RabbitMQMessageDto } from '@app/resources/dto/rabbitmq';

/**
 * Guild Message DTO for RabbitMQ
 *
 * Comprehensive data transfer object for guild messages with RabbitMQ routing.
 * Combines GuildJobQueueDto logic with RabbitMQ-specific metadata.
 * Includes static factory methods for each source with automatic guid generation,
 * validation, and transformation logic.
 *
 * SOURCES:
 * @see GuildsService.indexGuildCharactersUnique() - Guilds from character rosters (priority: 1)
 * @see GuildsService.indexGuilds() - Guild database index (priority: 5)
 * @see GuildsService.indexHallOfFame() - Top guilds from Blizzard leaderboards (priority: 2)
 * @see WowProgressRanksService.transformWowProgressToGuildJobs() - WoW Progress rankings (priority: 3)
 * @see OsintService.getGuild() - Direct guild API request (priority: 1)
 *
 * GUID FORMAT:
 * - Generated by toGuid(name, realm)
 * - Kebab-case, lowercased, trimmed, no spaces
 * - Format: "guild-name@realm-slug"
 * - Example: toGuid('Thrall', 'Area 52') => 'thrall@area-52'
 */

/**
 * Base interface for creating guild message entries
 * Only requires essential fields; guid is auto-generated from name + realm
 */
export interface IGuildMessageBase {
  /** Guild name (will be converted to kebab-case for guid) */
  name: string;
  /** Realm slug (will be converted to kebab-case for guid) */
  realm: string;
  /** API key credentials */
  clientId?: string;
  clientSecret?: string;
  accessToken?: string;
  /** Force update threshold in milliseconds */
  forceUpdate: number;
  /** Only create if guild doesn't exist */
  createOnlyUnique: boolean;
  /** Source that last updated this job */
  updatedBy: OSINT_SOURCE;
  /** Source that created this job (optional, defaults to updatedBy) */
  createdBy?: OSINT_SOURCE;
}

export class GuildMessageDto extends RabbitMQMessageDto<any> {
  private static readonly guildLogger = new Logger(GuildMessageDto.name);

  private static isRabbitMQMessageBase<T>(
    params: any,
  ): params is IRabbitMQMessageBase<T> {
    return !!params && typeof params === 'object' && 'data' in (params as any);
  }

  /**
   * Private static method to perform type guard
   * @param params - any to be validated
   * @returns true if params has 'name' and 'realm' fields
   */
  private static isGuildCreateParams(
    params: any,
  ): params is Omit<Partial<GuildMessageDto>, 'guid'> &
    Pick<IGuildMessageBase, 'name' | 'realm'> {
    return (
      !!params && typeof params === 'object' && 'name' in params && 'realm' in params
    );
  }

  // Guild Job Queue properties
  readonly guid: string;
  readonly name: string;
  readonly realm: string;
  readonly realmId?: number;
  readonly realmName?: string;
  readonly faction?: string;
  readonly statusCode?: number;
  readonly achievementPoints?: number;
  readonly forceUpdate: number;
  readonly createOnlyUnique: boolean;
  readonly iteration?: number;
  readonly createdBy?: OSINT_SOURCE;
  readonly updatedBy: OSINT_SOURCE;
  readonly clientId?: string;
  readonly clientSecret?: string;
  readonly accessToken?: string;
  readonly region: 'eu';
  readonly createdAt?: Date;
  readonly updatedAt?: Date;

  /**
   * Constructor - creates a validated Guild Message with RabbitMQ metadata
   * @param params - Guild message parameters
   */
  constructor(params: any) {
    // Extract guild job queue data
    const guildData = params.data || params;

    // Call parent constructor with RabbitMQ metadata
    super({
      id: params.id || guildData.guid,
      data: guildData,
      priority: params.priority ?? 5,
      source: params.source ?? OSINT_SOURCE.GUILD_INDEX,
      routingKey: params.routingKey ?? 'osint.guilds.index.normal',
      persistent: params.persistent ?? true,
      expiration: params.expiration,
      metadata: params.metadata,
    });

    // Assign guild job queue properties
    Object.assign(this, guildData);

    // Set default region if not provided
    if (!this.region) {
      (this as any).region = 'eu';
    }
  }

  /**
   * Create with auto-generated guid from name and realm
   * @returns New GuildMessageDto instance with generated guid
   * @param params
   */
  static create<T>(params: IRabbitMQMessageBase<T>): RabbitMQMessageDto<T>;
  static create(
    data: Omit<Partial<GuildMessageDto>, 'guid'> &
      Pick<IGuildMessageBase, 'name' | 'realm'>,
  ): GuildMessageDto;
  static create(
    params:
      | IRabbitMQMessageBase<any>
      | (Omit<Partial<GuildMessageDto>, 'guid'> &
          Pick<IGuildMessageBase, 'name' | 'realm'>),
  ): RabbitMQMessageDto<any> | GuildMessageDto {
    if (GuildMessageDto.isRabbitMQMessageBase(params)) {
      return RabbitMQMessageDto.create(params);
    }

    if (!GuildMessageDto.isGuildCreateParams(params)) {
      throw new Error(
        'GuildMessageDto.create expected guild params with name and realm.',
      );
    }

    const guid = toGuid(params.name, params.realm);
    const dto = new GuildMessageDto({
      ...params,
      guid,
      createdBy: params.createdBy || params.updatedBy,
    });
    dto.validate(false, 'GuildMessageDto.create');
    return dto;
  }

  /**
   * Create from Guild Characters Unique (discovered from character rosters)
   * Pattern: GuildsService.indexGuildCharactersUnique
   */
  static fromGuildCharactersUnique(params: {
    name: string;
    realm: string;
    clientId: string;
    clientSecret: string;
    accessToken: string;
  }): GuildMessageDto {
    const guid = toGuid(params.name, params.realm);
    const dto = new GuildMessageDto({
      guid,
      name: params.name,
      realm: params.realm,
      forceUpdate: 14400000, // 4 hours
      region: 'eu',
      createdBy: OSINT_SOURCE.GUILD_CHARACTERS_UNIQUE,
      updatedBy: OSINT_SOURCE.GUILD_CHARACTERS_UNIQUE,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
      // RabbitMQ metadata
      id: guid,
      priority: 7,
      source: OSINT_SOURCE.GUILD_CHARACTERS_UNIQUE,
      routingKey: 'osint.guilds.roster.high',
      persistent: true,
      expiration: 3600000, // 1 hour TTL
    });
    dto.validate(false, 'GuildMessageDto.fromGuildCharactersUnique');
    return dto;
  }

  /**
   * Create from Guild Index (database guild roster)
   * Pattern: GuildsService.indexGuilds
   */
  static fromGuildIndex(params: {
    guid: string;
    name: string;
    realm: string;
    iteration: number;
    clientId: string;
    clientSecret: string;
    accessToken: string;
    // All other GuildsEntity fields
    [key: string]: any;
  }): GuildMessageDto {
    const dto = new GuildMessageDto({
      ...params,
      region: 'eu',
      forceUpdate: 14400000, // 4 hours
      createdBy: OSINT_SOURCE.GUILD_INDEX,
      updatedBy: OSINT_SOURCE.GUILD_INDEX,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
      iteration: params.iteration,
      // RabbitMQ metadata
      id: params.guid,
      priority: 5,
      source: OSINT_SOURCE.GUILD_INDEX,
      routingKey: 'osint.guilds.index.normal',
      persistent: true,
      expiration: 43200000, // 12 hours TTL
    });
    dto.validate(false, 'GuildMessageDto.fromGuildIndex');
    return dto;
  }

  /**
   * Create from Hall of Fame (Blizzard leaderboards)
   * Pattern: GuildsService.indexHallOfFame
   * Note: Only EU region is supported - any other region will be ignored and defaulted to EU
   */
  static fromHallOfFame(params: {
    name: string;
    realm: string;
    realmId: number;
    realmName: string;
    faction: string;
    rank: number;
    region?: 'eu' | 'us' | 'kr' | 'tw';
    clientId: string;
    clientSecret: string;
    accessToken: string;
  }): GuildMessageDto {
    const guid = toGuid(params.name, params.realm);
    // Log warning if non-EU region was provided
    if (params.region && params.region !== 'eu') {
      GuildMessageDto.guildLogger.warn({
        logTag: 'GuildMessageDto.fromHallOfFame',
        message: `Non-EU region '${params.region}' provided but only EU is supported. Defaulting to 'eu'.`,
        guid,
        providedRegion: params.region,
      });
    }
    const dto = new GuildMessageDto({
      guid,
      name: params.name,
      realm: params.realm,
      realmId: params.realmId,
      realmName: params.realmName,
      faction: params.faction,
      iteration: params.rank,
      forceUpdate: 3600000, // 1 hour
      region: 'eu', // Always use EU
      createdBy: OSINT_SOURCE.TOP100,
      updatedBy: OSINT_SOURCE.TOP100,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
      // RabbitMQ metadata
      id: guid,
      priority: 9, // Highest priority for Hall of Fame guilds
      source: OSINT_SOURCE.TOP100,
      routingKey: 'osint.guilds.hof.urgent',
      persistent: true,
      expiration: 600000, // 10 minutes TTL
    });
    dto.validate(false, 'GuildMessageDto.fromHallOfFame');
    return dto;
  }

  /**
   * Create from WoW Progress rankings
   * Pattern: WowProgressRanksService.transformWowProgressToGuildJobs
   */
  static fromWowProgress(params: {
    name: string;
    realm: string;
    iteration: number;
    clientId: string;
    clientSecret: string;
    accessToken: string;
  }): GuildMessageDto {
    const guid = toGuid(params.name, params.realm);
    const dto = new GuildMessageDto({
      guid,
      name: params.name,
      realm: params.realm,
      iteration: params.iteration,
      forceUpdate: 43200000, // 12 hours
      region: 'eu',
      createdBy: OSINT_SOURCE.WOW_PROGRESS,
      updatedBy: OSINT_SOURCE.WOW_PROGRESS,
      createOnlyUnique: true, // Only create new, don't update existing
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
      // RabbitMQ metadata
      id: guid,
      priority: 6,
      source: OSINT_SOURCE.WOW_PROGRESS,
      routingKey: 'osint.guilds.wowprogress.normal',
      persistent: true,
      expiration: 7200000, // 2 hours TTL
    });
    dto.validate(false, 'GuildMessageDto.fromWowProgress');
    return dto;
  }

  /**
   * Create from Guild Request (direct API request for specific guild)
   * Pattern: OsintService.getGuild
   */
  static fromGuildRequest(params: {
    name: string;
    realm: string;
    clientId?: string;
    clientSecret?: string;
    accessToken?: string;
  }): GuildMessageDto {
    const guid = toGuid(params.name, params.realm);
    const dto = new GuildMessageDto({
      guid,
      name: params.name,
      realm: params.realm,
      forceUpdate: 86400000, // 24 hours
      region: 'eu',
      createdBy: OSINT_SOURCE.GUILD_REQUEST,
      updatedBy: OSINT_SOURCE.GUILD_REQUEST,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
      // RabbitMQ metadata
      id: guid,
      priority: 8, // High priority for user requests
      source: OSINT_SOURCE.GUILD_REQUEST,
      routingKey: 'osint.guilds.request.high',
      persistent: true,
      expiration: 1800000, // 30 minutes TTL
    });
    dto.validate(false, 'GuildMessageDto.fromGuildRequest');
    return dto;
  }

  /**
   * Validate that required fields are present
   * @param strict - If true, throws errors; if false, logs warnings
   * @param logTag - Optional log tag for warnings (defaults to 'GuildMessageDto.validate')
   * @throws Error if validation fails and strict is true
   */
  validate(
    strict: boolean = true,
    logTag: string = 'GuildMessageDto.validate',
  ): void {
    const requiredFields = [
      'guid',
      'name',
      'realm',
      'forceUpdate',
      'createOnlyUnique',
      'updatedBy',
    ];

    // Check required fields
    for (const field of requiredFields) {
      if (this[field] === undefined || this[field] === null) {
        const message = `Validation failed: missing required field '${field}' for guid '${this.guid || 'unknown'}'`;
        if (strict) {
          throw new Error(message);
        } else {
          GuildMessageDto.guildLogger.warn({
            logTag,
            message,
            guid: this.guid,
          });
        }
      }
    }

    // Validate guid format
    if (this.guid && !this.guid.includes('@')) {
      const message = `Validation failed: guid '${this.guid}' must contain '@' separator`;
      if (strict) {
        throw new Error(message);
      } else {
        GuildMessageDto.guildLogger.warn({ logTag, message, guid: this.guid });
      }
    }

    // Validate forceUpdate is positive number
    if (
      this.forceUpdate !== undefined &&
      (typeof this.forceUpdate !== 'number' || this.forceUpdate < 0)
    ) {
      const message = `Validation failed: forceUpdate must be a positive number, got '${this.forceUpdate}' for guid '${this.guid || 'unknown'}'`;
      if (strict) {
        throw new Error(message);
      } else {
        GuildMessageDto.guildLogger.warn({
          logTag,
          message,
          guid: this.guid,
          forceUpdate: this.forceUpdate,
        });
      }
    }

    // Warn about missing optional credentials (non-blocking)
    if (!strict) {
      const credentials = ['clientId', 'clientSecret', 'accessToken'];
      const missingCredentials = credentials.filter(
        (field) => !this[field] || this[field] === undefined,
      );
      if (missingCredentials.length > 0) {
        GuildMessageDto.guildLogger.warn({
          logTag,
          message: `Missing optional credentials: ${missingCredentials.join(', ')}`,
          guid: this.guid,
          missingCredentials,
        });
      }
    }
  }

  /**
   * Create validated instance - throws if validation fails
   */
  static createValidated(
    data: Omit<Partial<GuildMessageDto>, 'guid'> &
      Pick<IGuildMessageBase, 'name' | 'realm'>,
  ): GuildMessageDto {
    const dto = GuildMessageDto.create(data);
    dto.validate();
    return dto;
  }
}
