import { toGuid } from '../../transformers';
import { OSINT_SOURCE, TIME_MS } from '../../constants';
import { Logger } from '@nestjs/common';
import { IQueueMessageBase, QueueMessageDto } from '@app/resources/dto/queue';
import { RegionIdOrName } from '@alexzedim/blizzapi';

/**
 * Guild Message DTO for BullMQ
 *
 * Comprehensive data transfer object for guild jobs with BullMQ.
 * Includes static factory methods for each source with automatic guid generation,
 * validation, and transformation logic.
 *
 * SOURCES:
 * @see GuildsService.indexGuildCharactersUnique() - Guilds from character rosters (priority: 7)
 * @see GuildsService.indexGuilds() - Guild database index (priority: 5)
 * @see GuildsService.indexHallOfFame() - Top guilds from Blizzard leaderboards (priority: 9)
 * @see WowProgressRanksService.transformWowProgressToGuildJobs() - WoW Progress rankings (priority: 6)
 * @see OsintService.getGuild() - Direct guild API request (priority: 8)
 *
 * GUID FORMAT:
 * - Generated by toGuid(name, realm)
 * - Kebab-case, lowercased, trimmed, no spaces
 * - Format: "guild-name@realm-slug"
 * - Example: toGuid('Thrall', 'Area 52') => 'thrall@area-52'
 */

/**
 * Base interface for creating guild job data
 * Only requires essential fields; guid is auto-generated from name + realm
 */
export interface IGuildMessageBase {
  id?: number;
  guid?: string;
  region: RegionIdOrName;
  /** Guild name (will be converted to kebab-case for guid) */
  name: string;
  /** Realm slug (will be converted to kebab-case for guid) */
  realm: string;
  /** API key credentials */
  clientId?: string;
  clientSecret?: string;
  accessToken?: string;
  /** Force update threshold in milliseconds */
  forceUpdate: number;
  /** Only create if guild doesn't exist */
  createOnlyUnique: boolean;
  /** Source that last updated this job */
  updatedBy: OSINT_SOURCE;
  /** Source that created this job (optional, defaults to updatedBy) */
  createdBy?: OSINT_SOURCE;
}

export class GuildMessageDto extends QueueMessageDto<IGuildMessageBase> {
  private static readonly guildLogger = new Logger(GuildMessageDto.name);

  private static isQueueMessageBase<T>(
    params: any,
  ): params is IQueueMessageBase<T> {
    return !!params && typeof params === 'object' && 'data' in (params as any);
  }

  /**
   * Private static method to perform type guard
   * @param params - any to be validated
   * @returns true if params has 'name' and 'realm' fields
   */
  private static isGuildCreateParams(
    params: any,
  ): params is Omit<Partial<IGuildMessageBase>, 'guid'> &
      Pick<IGuildMessageBase, 'name' | 'realm'> {
    return (
      !!params && typeof params === 'object' && 'name' in params && 'realm' in params
    );
  }

  /**
   * Constructor - creates a validated Guild Message with BullMQ properties
   * @param params - Guild message parameters
   */
  constructor(params: any) {
    const messageParams = params ?? {};
    const { data, priority, source, attempts, metadata, ...rest } = messageParams;
    const guildData = data ? { ...rest, ...data } : rest;

    super({
      data: guildData,
      priority: priority ?? 5,
      source: source ?? OSINT_SOURCE.GUILD_INDEX,
      attempts,
      metadata,
    });
  }

  /**
   * Create with auto-generated guid from name and realm
   * @returns New GuildMessageDto instance with generated guid
   * @param params
   */
  static create<T>(params: IQueueMessageBase<T>): QueueMessageDto<T>;
  static create(
    data: Omit<Partial<IGuildMessageBase>, 'guid'> &
      Pick<IGuildMessageBase, 'name' | 'realm'>,
  ): GuildMessageDto;
  static create(
    params:
      | IQueueMessageBase<any>
      | (Omit<Partial<IGuildMessageBase>, 'guid'> &
          Pick<IGuildMessageBase, 'name' | 'realm'>),
  ): QueueMessageDto<any> | GuildMessageDto {
    if (GuildMessageDto.isQueueMessageBase(params)) {
      return QueueMessageDto.create(params);
    }

    if (!GuildMessageDto.isGuildCreateParams(params)) {
      throw new Error(
        'GuildMessageDto.create expected guild params with name and realm.',
      );
    }

    const guid = toGuid(params.name, params.realm);
    const dto = new GuildMessageDto({
      ...params,
      guid,
      createdBy: params.createdBy || params.updatedBy,
    });
    dto.validate(false, 'GuildMessageDto.create');
    return dto;
  }

  /**
   * Create from Guild Characters Unique (discovered from character rosters)
   * Pattern: GuildsService.indexGuildCharactersUnique
   */
  static fromGuildCharactersUnique(params: {
    name: string;
    realm: string;
    clientId: string;
    clientSecret: string;
    accessToken: string;
  }): GuildMessageDto {
    const guid = toGuid(params.name, params.realm);
    const dto = new GuildMessageDto({
      guid,
      name: params.name,
      realm: params.realm,
      forceUpdate: TIME_MS.FOUR_HOURS,
      region: 'eu',
      createdBy: OSINT_SOURCE.GUILD_CHARACTERS_UNIQUE,
      updatedBy: OSINT_SOURCE.GUILD_CHARACTERS_UNIQUE,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
      priority: 7,
      source: OSINT_SOURCE.GUILD_CHARACTERS_UNIQUE,
    });
    dto.validate(false, 'GuildMessageDto.fromGuildCharactersUnique');
    return dto;
  }

  /**
   * Create from Guild Index (database guild roster)
   * Pattern: GuildsService.indexGuilds
   */
  static fromGuildIndex(params: {
    guid: string;
    name: string;
    realm: string;
    iteration: number;
    clientId: string;
    clientSecret: string;
    accessToken: string;
    // All other GuildsEntity fields
    [key: string]: any;
  }): GuildMessageDto {
    const dto = new GuildMessageDto({
      ...params,
      region: 'eu',
      forceUpdate: TIME_MS.FOUR_HOURS,
      createdBy: OSINT_SOURCE.GUILD_INDEX,
      updatedBy: OSINT_SOURCE.GUILD_INDEX,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
      iteration: params.iteration,
      priority: 5,
      source: OSINT_SOURCE.GUILD_INDEX,
    });
    dto.validate(false, 'GuildMessageDto.fromGuildIndex');
    return dto;
  }

  /**
   * Create from Hall of Fame (Blizzard leaderboards)
   * Pattern: GuildsService.indexHallOfFame
   * Note: Only EU region is supported - any other region will be ignored and defaulted to EU
   */
  static fromHallOfFame(params: {
    id?: number;
    name: string;
    realm: string;
    realmId: number;
    realmName: string;
    faction: string;
    rank: number;
    region?: 'eu' | 'us' | 'kr' | 'tw';
    clientId: string;
    clientSecret: string;
    accessToken: string;
  }): GuildMessageDto {
    const guid = toGuid(params.name, params.realm);
    // Log warning if non-EU region was provided
    if (params.region && params.region !== 'eu') {
      GuildMessageDto.guildLogger.warn({
        logTag: 'GuildMessageDto.fromHallOfFame',
        message: `Non-EU region '${params.region}' provided but only EU is supported. Defaulting to 'eu'.`,
        guid,
        providedRegion: params.region,
      });
    }
    const dto = new GuildMessageDto({
      guid,
      id: params.id,
      name: params.name,
      realm: params.realm,
      realmId: params.realmId,
      realmName: params.realmName,
      faction: params.faction,
      iteration: params.rank,
      forceUpdate: TIME_MS.ONE_HOUR,
      region: 'eu',
      createdBy: OSINT_SOURCE.TOP100,
      updatedBy: OSINT_SOURCE.TOP100,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
      priority: 9,
      source: OSINT_SOURCE.TOP100,
    });
    dto.validate(false, 'GuildMessageDto.fromHallOfFame');
    return dto;
  }

  /**
   * Create from WoW Progress rankings
   * Pattern: WowProgressRanksService.transformWowProgressToGuildJobs
   */
  static fromWowProgress(params: {
    name: string;
    realm: string;
    iteration: number;
    clientId: string;
    clientSecret: string;
    accessToken: string;
  }): GuildMessageDto {
    const guid = toGuid(params.name, params.realm);
    const dto = new GuildMessageDto({
      guid,
      name: params.name,
      realm: params.realm,
      iteration: params.iteration,
      forceUpdate: TIME_MS.TWELVE_HOURS,
      region: 'eu',
      createdBy: OSINT_SOURCE.WOW_PROGRESS,
      updatedBy: OSINT_SOURCE.WOW_PROGRESS,
      createOnlyUnique: true,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
      priority: 6,
      source: OSINT_SOURCE.WOW_PROGRESS,
    });
    dto.validate(false, 'GuildMessageDto.fromWowProgress');
    return dto;
  }

  /**
   * Create from Guild Request (direct API request for specific guild)
   * Pattern: OsintService.getGuild
   */
  static fromGuildRequest(params: {
    name: string;
    realm: string;
    clientId?: string;
    clientSecret?: string;
    accessToken?: string;
  }): GuildMessageDto {
    const guid = toGuid(params.name, params.realm);
    const dto = new GuildMessageDto({
      guid,
      name: params.name,
      realm: params.realm,
      forceUpdate: TIME_MS.TWENTY_FOUR_HOURS,
      region: 'eu',
      createdBy: OSINT_SOURCE.GUILD_REQUEST,
      updatedBy: OSINT_SOURCE.GUILD_REQUEST,
      createOnlyUnique: false,
      clientId: params.clientId,
      clientSecret: params.clientSecret,
      accessToken: params.accessToken,
      priority: 8,
      source: OSINT_SOURCE.GUILD_REQUEST,
    });
    dto.validate(false, 'GuildMessageDto.fromGuildRequest');
    return dto;
  }

  /**
   * Validate that required fields are present
   * @param strict - If true, throws errors; if false, logs warnings
   * @param logTag - Optional log tag for warnings (defaults to 'GuildMessageDto.validate')
   * @throws Error if validation fails and strict is true
   */
  validate(strict: boolean = true, logTag: string = 'GuildMessageDto.validate'): void {
    const guildData = this.data as IGuildMessageBase | undefined;

    if (guildData?.guid && !guildData.guid.includes('@')) {
      const message = `Validation failed: guid '${guildData.guid}' must contain '@' separator`;
      if (strict) {
        throw new Error(message);
      } else {
        GuildMessageDto.guildLogger.warn({
          logTag,
          message,
          guid: guildData.guid,
        });
      }
    }

    if (
      guildData?.forceUpdate !== undefined &&
      (typeof guildData.forceUpdate !== 'number' || guildData.forceUpdate < 0)
    ) {
      const message = `Validation failed: forceUpdate must be a positive number, got '${guildData.forceUpdate}' for guid '${guildData?.guid || 'unknown'}'`;
      if (strict) {
        throw new Error(message);
      } else {
        GuildMessageDto.guildLogger.warn({
          logTag,
          message,
          guid: guildData?.guid,
          forceUpdate: guildData?.forceUpdate,
        });
      }
    }

    // Warn about missing optional credentials (non-blocking)
    if (!strict) {
      const credentials = ['clientId', 'clientSecret', 'accessToken'];
      const missingCredentials = credentials.filter(
        (field) => !guildData?.[field] || guildData?.[field] === undefined,
      );
      if (missingCredentials.length > 0) {
        GuildMessageDto.guildLogger.warn({
          logTag,
          message: `Missing optional credentials: ${missingCredentials.join(', ')}`,
          guid: guildData?.guid,
          missingCredentials,
        });
      }
    }

    // Call parent validation
    super.validate(strict);
  }

  /**
   * Create validated instance - throws if validation fails
   */
  static createValidated(
    data: Omit<Partial<IGuildMessageBase>, 'guid'> &
      Pick<IGuildMessageBase, 'name' | 'realm'>,
  ): GuildMessageDto {
    const dto = GuildMessageDto.create(data);
    dto.validate();
    return dto;
  }
}
